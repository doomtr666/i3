using System;
using System.Collections.Generic;

class MatrixGenerator : GeneratorBase
{
    // Matrix types
    List<Tuple<int, int>> matrixSizes = [
        new Tuple<int,int>(3, 3),
        new Tuple<int,int>(3, 4),
        new Tuple<int,int>(4, 3),
        new Tuple<int,int>(4, 4)
    ];

    string MatrixName(int rows, int cols)
    {
        if (rows == cols)
            return $"i3_mat{rows}";
        return $"i3_mat{rows}{cols}";
    }

    string MatrixType(int rows, int cols)
    {
        return $"{MatrixName(rows, cols)}_t";
    }

    void GenerateHeader()
    {
        WriteLine("#pragma once");
        WriteLine("// This file is generated by mathlib_generator, do not edit manually.");
        WriteLine();
        WriteLine("#include \"vec.h\"");
        WriteLine();
    }

    void GenerateConstructor(int rows, int cols, bool decl)
    {
        string name = MatrixName(rows, cols);
        string type = MatrixType(rows, cols);

        Write($"static inline {type} {name}(");
        for (int i = 0; i < rows; ++i)
        {
            for (int j = 0; j < cols; ++j)
            {
                if (i != 0 || j != 0)
                    Write(", ");
                Write($"float m{i}{j}");
            }
        }

        Write(")");

        if (decl)
            WriteLine(";");
        else
        {
            WriteLine();
            WriteLine("{");
            WriteLine($"{type} r;", 1);
            for (int i = 0; i < rows; ++i)
                for (int j = 0; j < cols; ++j)
                    WriteLine($"r.m{i}{j} = m{i}{j};", 1);
            WriteLine("return r;", 1);
            WriteLine("}");
            WriteLine();
        }
    }

    void GenerateSet(int rows, int cols, bool decl)
    {
        string name = MatrixName(rows, cols);
        string type = MatrixType(rows, cols);

        Write($"static inline {type} {name}_set(float v)");

        if (decl)
            WriteLine(";");
        else
        {
            WriteLine();
            WriteLine("{");
            WriteLine($"{type} r;", 1);
            for (int i = 0; i < rows; ++i)
                for (int j = 0; j < cols; ++j)
                    WriteLine($"r.m{i}{j} = v;", 1);
            WriteLine("return r;", 1);
            WriteLine("}");
            WriteLine();
        }

        Write($"static inline {type} {name}_zero()");

        if (decl)
            WriteLine(";");
        else
        {
            WriteLine();
            WriteLine("{");
            WriteLine($"return {name}_set(0);", 1);
            WriteLine("}");
            WriteLine();
        }
    }

    void GenerateIndentity(int rows, int cols, bool decl)
    {
        string name = MatrixName(rows, cols);
        string type = MatrixType(rows, cols);

        Write($"static inline {type} {name}_identity()");

        if (decl)
            WriteLine(";");
        else
        {
            WriteLine();
            WriteLine("{");
            WriteLine($"{type} r;", 1);
            for (int i = 0; i < rows; ++i)
                for (int j = 0; j < cols; ++j)
                    WriteLine($"r.m{i}{j} = {(i == j ? 1.0f : 0.0f)};", 1);
            WriteLine("return r;", 1);
            WriteLine("}");
            WriteLine();
        }
    }

    void GenerateStr(int rows, int cols, bool decl = true)
    {
        string name = MatrixName(rows, cols);
        string type = MatrixType(rows, cols);

        Write($"static inline const char* {name}_str({type} m)");

        if (decl)
            WriteLine(";");
        else
        {
            WriteLine();
            WriteLine("{");
            WriteLine($"static char buffer[{rows * cols * 16}];", 1);
            Write($"snprintf(buffer, sizeof(buffer), \"[", 1);
            for (int i = 0; i < rows; ++i)
            {
                Write("[");
                for (int j = 0; j < cols; ++j)
                {
                    if (j != 0)
                        Write(" ");
                    Write("%f");
                }
                Write("]");
            }

            Write("]\"");

            for (int i = 0; i < rows; ++i)
                for (int j = 0; j < cols; ++j)
                    Write($", m.m{i}{j}");
            WriteLine(");");
            WriteLine("return buffer;", 1);
            WriteLine("}");
            WriteLine();
        }
    }

    void GenerateMatrixFunction(int rows, int cols, bool decl = true)
    {
        if (!decl)
            WriteLine($"// implementation of {MatrixType(rows, cols)}");
        GenerateConstructor(rows, cols, decl);
        GenerateSet(rows, cols, decl);
        if (rows == cols)
            GenerateIndentity(rows, cols, decl);
        GenerateStr(rows, cols, decl);
    }

    void GenerateMatrix(int rows, int cols)
    {
        string matrixName = MatrixName(rows, cols);
        string matrixType = MatrixType(rows, cols);

        WriteLine($"// {matrixType}");
        WriteLine($"typedef struct {matrixType}");
        WriteLine("{");
        WriteLine("union", 1);
        WriteLine("{", 1);
        WriteLine($"float m[{rows * cols}];", 2);
        WriteLine("struct", 2);
        WriteLine("{", 2);
        for (int i = 0; i < rows; ++i)
        {
            Write("float ", 3);
            for (int j = 0; j < cols; ++j)
            {
                if (j != 0)
                    Write(", ");
                Write($"m{i}{j}");
            }
            WriteLine(";");
        }
        WriteLine("};", 2);
        WriteLine("struct", 2);
        WriteLine("{", 2);
        for (int i = 0; i < rows; ++i)
            WriteLine($"{VectorGenerator.VectorType(cols)} v{i};", 3);
        WriteLine("};", 2);
        WriteLine("};", 1);
        WriteLine($"}} {matrixType};");
        WriteLine();

        GenerateMatrixFunction(rows, cols);
        WriteLine();
    }

    public override void Generate()
    {
        GenerateHeader();

        foreach (var size in matrixSizes)
            GenerateMatrix(size.Item1, size.Item2);

        foreach (var size in matrixSizes)
            GenerateMatrixFunction(size.Item1, size.Item2, false);
    }
}